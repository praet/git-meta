#!/usr/bin/env bash
#
#  git-meta - Track metadata of git-versioned files and folders
#  Copyright (C) 2011  Pieter Praet <pieter@praet.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

META_FILE=".gitmeta"    # Default target for the metadata info.
META_FILE_TIMESTAMP=no  # Include timestamp at top of metadata file?
META_FILE_INCLUDE=no    # Track metadata for the metadata file itself?
META_FILE_OFFSET=4      # Where does the actual metadata info start?

META_DEREF_SYMLINKS=no

PROGNAME=$(basename "${0}")
PROGVER="@VERSIONTAG@"

function usage() {
    1>&2 cat <<EOF
${PROGNAME} ${PROGVER}
Usage:  ${PROGNAME} [ COMMAND ] [ META_FILE ]

${PROGNAME} tracks useful metadata of git-versioned files as well as the
folders they reside in, using a merge-friendly metadata storage format.

Currently the following types of metadata are stored:
- Modification time (as seconds since Epoch)
- User ownership (user name, not UID)
- Group ownership (group name, not GID)
- Access rights (in octal)

Metadata info is read and written from/to a file called \`\`${META_FILE}''
in the root of the repo's working tree, though most commands (the ones
for which it makes sense) can be provided with an alternate filename.


COMMANDS:
  p, print         print metadata to standard output
  v, validate      validate a metadata file
  d, diff          compare current metadata to a metadata file
  s, save          save current metadata to a metadata file
  r, restore       restore metadata from a metadata file

  -h, --help       display this help and exit
  -v, --version    output version information and exit

${PROGNAME} home page: <http://github/praet/git-meta/>
Report ${PROGNAME} bugs to: Pieter Praet <pieter@praet.org>
Be sure to include the word \`\`${PROGNAME}'' somewhere in the \`\`Subject:'' field.
EOF
    exit 0
}

function version() {
    1>&2 cat <<EOF
${PROGNAME} ${PROGVER}
Copyright (C) 2011 Pieter Praet
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,
to the extent permitted by law.

${PROGNAME} home page: <http://github/praet/git-meta/>
Report ${PROGNAME} bugs to: Pieter Praet <pieter@praet.org>
Be sure to include the word \`\`${PROGNAME}'' somewhere in the \`\`Subject:'' field.
EOF
    exit 0
}

function msg-info()  {  echo -e "${PROGNAME}: (I) $@" ;                }
function msg-error() {  echo -e "${PROGNAME}: (E) $@" >&2 ; return 1 ; }
function msg-exit()  {  echo -e "${PROGNAME}: (E) $@" >&2 ; exit 1 ;   }


function git-meta-get-files() {
    git ls-files --cached -z | \
        while read -r -d $'\0' line ; do
            echo "${line}"
        done
}

function git-meta-get-folders() {
    # FIXME: This is extremely convoluted and way too expensive.
    while read folder ; do
        until [ -z "${folder}" ] ; do
            echo "${folder}"
            folder="$(echo ${folder} | sed --expression='s/^\(.*\/\)\?\(.*\/\)\+$/\1/')"
        done
    done <<< "$(git-meta-get-files | grep --only-matching --regexp='^\(.*\/\)\+')" | \
        sort --unique
}

function git-meta-get-targets() {
    # FIXME: `git-meta-get-files' is essentially called twice here:
    #        once directly and once by `git-meta-get-folders',
    #        causing a considerable performance hit.
    LC_ALL=C sort <<< "$(git-meta-get-files ; git-meta-get-folders)"
}

function git-meta-get-target-metadata() {
    local target="${1}"
    local opts=""

    test "${META_DEREF_SYMLINKS}" == "yes" \
        && opts="${opts} --dereference"

    env stat ${opts} --format="%Y;%U;%G;%a" "./${target}"
}

function git-meta-generate() {
    echo "# Generated by git-meta. Edit at your own risk."

    test "${META_FILE_TIMESTAMP}" == "yes" \
        && echo -e "# $(date "+%A %Y-%m-%d %H:%M:%S%z (%Z)")\n" \
        || echo -e "#\n"

    #git-meta-get-files | \
    while read target ; do

        test -e "${target}" \
            || { # Prevent issues with broken symlinks
                 test "${META_DEREF_SYMLINKS}" == "no" && test -h "${target}" ;
               } \
            || msg-exit "Does not exist: '${target}'. Please update the index. Aborting..."

        local output="$(git-meta-get-target-metadata "${target}");${target};"

        test "${META_FILE_INCLUDE}" != "yes" \
            && output=$(echo "${output}" | eval $(echo "grep --invert-match ';${META_FILE};\$'"))

        test -n "${output}" \
            && { git-meta-validate-line "${output}" \
                     && echo "${output}" \
                     || msg-exit "Malformed metadata line:\n  ${output}\nAborting..."  ; }

    done <<< "$(git-meta-get-targets)"
    #done
}

function git-meta-validate-line() {
    local line="${1}"
    local valid=$(echo "${line}" | \
        grep --regexp='^\([[:digit:]]\{10\}\);\([[:alpha:]]\+\);\([[:alpha:]]\+\);\([[:digit:]]\{3\}\);\([^;]\+\);$')

    return $(test "${line}" == "${valid}")
}

function git-meta-validate() {
    local metafile="${1}"
    local linum=0
    local errnum=0

    msg-info "Validating '${metafile}'..."

    test -r "${metafile}" \
        || msg-exit "Can't read from '${metafile}'."

    #tail --lines="+${META_FILE_OFFSET}" "${metafile}" | \
    while read line ; do
        git-meta-validate-line "${line}" \
            || { echo "  err line $(( ${linum} + ${META_FILE_OFFSET} )) : '${line}'" ;
                 errnum=$(( ${errnum} + 1 )) ; }
        linum=$(( ${linum} + 1 ))
    done <<< "$(tail --lines=+"${META_FILE_OFFSET}" "${metafile}")"
    #done

    test "${errnum}" == 0 \
        && msg-info "Validating: DONE" \
        || msg-exit "Validating: FAILED -- Encountered ${errnum} malformed metadata lines."
}

function git-meta-diff() {
    local metafile="${1}"

    msg-info "Diffing current metadata to '${metafile}'..."

    test -r "${metafile}" \
        || msg-exit "Can't read from '${metafile}'."

    local metatmp="$(mktemp -t git-meta.XXXXXXXXXX)"
    git-meta-generate > "${metatmp}"

    local metadiff=$(diff --unified=0 "${metafile}" "${metatmp}")
    test -n "${metadiff}" \
        && echo "${metadiff}" \
        || msg-info "Diffing: Nothing changed."

    rm "${metatmp}"
}

function git-meta-save() {
    local metafile="${1}"

    msg-info "Saving metadata to '${metafile}'..."

    touch "${metafile}" 2>/dev/null \
        || msg-exit "Can't write to '${metafile}'."

    git-meta-generate > "${metafile}" \
        || msg-exit "Failed while writing to '${metafile}'."

    git add "${metafile}"
    msg-info "Saving: DONE"
}

function git-meta-set-mtime(){
    local filename="${1}"
    local mtime="${2}"
    local opts="--no-create --time=modify"

    test "${META_DEREF_SYMLINKS}" == "yes" \
        || opts="${opts} --no-dereference"

    env touch ${opts} --date="@${mtime}" "./${filename}"
}

function git-meta-set-owner(){
    local filename="${1}"
    local user="${2}"
    local group="${3}"
    local opts="--changes"

    test "${META_DEREF_SYMLINKS}" == "yes" \
        || opts="${opts} --no-dereference"

    chown ${opts} "${user}":"${group}" "./${filename}"
}

function git-meta-set-perms(){
    local filename="${1}"
    local perms="${2}"
    local opts="--changes"

    ( test ! -h "./${filename}" || test "${META_DEREF_SYMLINKS}" == "yes" ) \
        && chmod ${opts} "${perms}" "./${filename}" \
        || return 0
}

function git-meta-restore() {
    local metafile="${1}"
    local errnum=0

    git-meta-validate "${metafile}"

    msg-info "Restoring metadata from '${metafile}'..."

    test -r "${metafile}" \
        || msg-exit "Can't read from '${metafile}'."

    while read line ; do
        # FIXME: Cut the `cut' crap, this should be a one-liner !
        mtime=$(echo "${line}" | cut --delimiter=";" --fields=1)
        user=$(echo "${line}" | cut --delimiter=";" --fields=2)
        group=$(echo "${line}" | cut --delimiter=";" --fields=3)
        perms=$(echo "${line}" | cut --delimiter=";" --fields=4)
        filename=$(echo "${line}" | cut --delimiter=";" --fields=5)

        test -e "./${filename}" \
            || { # Prevent issues with broken symlinks
                 test "${META_DEREF_SYMLINKS}" == "no" && test -h "./${filename}" ;
               } \
            && { git-meta-set-mtime "${filename}" "${mtime}" \
                     || errnum=$(( ${errnum} + 1 )) ;
                 git-meta-set-owner "${filename}" "${user}" "${group}" \
                     || errnum=$(( ${errnum} + 1 )) ;
                 git-meta-set-perms "${filename}" "${perms}" \
                     || errnum=$(( ${errnum} + 1 )) ; } \
            || { errnum=$(( ${errnum} + 1 )) ;
                 msg-error "Does not exist: '${filename}'" ; }

    done <<< "$(tail --lines=+"${META_FILE_OFFSET}" "${metafile}")"

    test "${errnum}" == 0 \
        && msg-info "Restoring: DONE" \
        || msg-exit "Restoring: PARTIAL -- Encountered ${errnum} errors."
}

repo_root="$(git rev-parse --show-toplevel)" \
    || msg-exit "Not in a git repo?"

pushd "${repo_root}" 1>/dev/null

# FIXME: Should be using `getopts' here...
test -n "${2}" && META_FILE="${2}"
case "${1}" in
    p | print    ) git-meta-generate                ;;
    v | validate ) git-meta-validate "${META_FILE}" ;;
    d | diff     ) git-meta-diff "${META_FILE}"     ;;
    s | save     ) git-meta-save "${META_FILE}"     ;;
    r | restore  ) git-meta-restore "${META_FILE}"  ;;

    -v | --version ) version                        ;;
    *              ) usage                          ;;
esac

popd 1>/dev/null


## EOF
